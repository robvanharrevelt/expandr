#' @import stringr

expand_expression <- function(expr, expa_list) {
    expressions <- expr
    for (pattern in names(expa_list)) {

        # TODO: if pattern not in expression, then do not do anything
        expressions <- lapply(expressions, FUN = str_replace_all, pattern = pattern,
                              replacement = expa_list[[pattern]])

        # convert list to character vector
        expressions <- do.call(what = c, args = expressions)
    }
    return (expressions)
}

evaluate_expr <- function(expr, envir, enclos = NULL) {
    expr <- parse(text = expr)
    return (eval(expr, envir = envir))
}

# returns a valid pattern(s) for regular expressions for a normal
# character vector x by escaping characters when necessary
create_pattern <- function(x) {
    return(str_replace_all(x, pattern = "([({)}+*])", replacement = "\\\\\\1"))
}

get_summation <- function(x, aggn_list) {
    x <- expand_expression(x, aggn_list)
    return(paste(x, collapse = " + "))
}

perform_aggregation <- function(expr, aggn_list) {

    # TODO: the code cannot handle multi-dimensional aggregations yet
    matches <- str_match_all(expr, pattern  = "\"\\{(.+?)\\}\"")

    # TODO: if no match, then return and keep exp unchanged
    groups <- matches[[1]][, 2]

    if (length(groups) == 0) {
        return (expr)
    }
    patterns <- create_pattern(groups)

    replacements <- lapply(groups, FUN = get_summation, aggn_list = aggn_list)
    replacements <- as.character(replacements)

    pattern_list <- replacements

    names(pattern_list) <- paste0("\"\\{", patterns, "\\}\"")

    expr <- str_replace_all(expr, pattern_list)
    return (expr)
}

presim_single_expression <- function(expr, expa_list, aggn_list, debug, envir) {

    if (length(aggn_list) > 0) {
        expr <- perform_aggregation(expr, aggn_list)
    }

    if (length(expa_list) > 0) {
        expressions <- expand_expression(expr, expa_list)
    } else {
        expressions <- expr
    }

    return (expressions)

}

#' The R version of the Presim program created by Arie ten Cate
#' @param x one or more R-expressions
#'
#' @export
presim <- function(expr) {
    expr <- substitute(expr)
    expr <- deparse(expr, width.cutoff = 500L)

    # initialisation
    expressions <- character(0)
    expa_list <- list()
    aggn_list <- list()

    for (expr in expr) {
        if (expr == "{" | expr == "}") {
            next
        }
        if (str_detect(expr,"\"\\$EXPA\"")) {
            expr <- str_replace(expr, pattern = "\"\\$EXPA\"",
                                replacement = "expa_list")
            eval(parse(text = expr))
        } else if (str_detect(expr,"\"\\$AGGN\"")) {
            expr <- str_replace(expr, pattern = "\"\\$AGGN\"",
                    replacement = "aggn_list")
            eval(parse(text = expr))
        } else {
            expressions <- c(expressions,
                         presim_single_expression(expr, expa_list, aggn_list,
                                                  debug,
                                                  envir = parent.frame()))
        }
    }

    return (structure(expressions, class = "presim"))
}

#' @export
print.presim <- function(x) {
    cat("S3 class presim\n")
    cat(paste(x, collapse = "\n"))
    cat("\n")
}

#' Evaluate presim code in the parent environment
#'
#' @param code generated by function <code>presim</code>
#' @export
evaluate_presim <- function(code) {
    x <- lapply(code, FUN = evaluate_expr, envir = parent.frame())
    return (NULL)
}

#' Evaluate presim code in the environment of a dataframe or list
#'
#' @param code generated by function <code>presim</code>
#' @param within dataframe or list within which the presim code is executed
#' @export
evaluate_presim_within <- function(code, x) {
    res <- within(x, {
        evaluate_presim(code)
    })
    return (res)
}
